website,api,code
https://raw.githubusercontent.com/apache/airflow/09880741cbfc4c1e6d433d1e7fac60deccd10a97/dev/send_email.py,"['sendmail', 'SMTP', 'login']","['Output sendmail:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str | list,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================', 'Output SMTP:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str | list,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================', 'Output SMTP:\ndef inter_send_email(\n    username: str, password: str, sender_email: str, receiver_email: str | list, message: str\n):\n    """"""\n    Send email using SMTP\n    """"""\n    show_message(""SMTP"", message)\n\n    click.confirm(""Is the Email message ok?"", abort=True)\n\n    try:\n        send_email(\n            SMTP_SERVER,\n            SMTP_PORT,\n            username,\n            password,\n            sender_email,\n            receiver_email,\n            message,\n        )\n        click.secho(""âœ… Email sent successfully"", fg=""green"")\n    except smtplib.SMTPAuthenticationError:\n        sys.exit(""SMTP User authentication error, Email not sent!"")\n    except Exception as e:\n        sys.exit(f""SMTP exception {e}"")\n========================================', 'Output login:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str | list,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================']"
https://raw.githubusercontent.com/geekcomputers/Python/96d0eb61826cbd1e88251e8bb5237a009d0b5a10/JARVIS/JARVIS_2.0.py,"['sendmail', 'SMTP', 'login']","['Output sendmail:\ndef sendEmail(to, content):\n    server = smtplib.SMTP(""smtp.gmail.com"", 587)\n    server.ehlo()\n    server.starttls()\n    server.login(""youremail@gmail.com"", ""yourr-password-here"")\n    server.sendmail(""youremail@gmail.com"", to, content)\n    server.close()\n========================================', 'Output SMTP:\ndef sendEmail(to, content):\n    server = smtplib.SMTP(""smtp.gmail.com"", 587)\n    server.ehlo()\n    server.starttls()\n    server.login(""youremail@gmail.com"", ""yourr-password-here"")\n    server.sendmail(""youremail@gmail.com"", to, content)\n    server.close()\n========================================', 'Output login:\ndef sendEmail(to, content):\n    server = smtplib.SMTP(""smtp.gmail.com"", 587)\n    server.ehlo()\n    server.starttls()\n    server.login(""youremail@gmail.com"", ""yourr-password-here"")\n    server.sendmail(""youremail@gmail.com"", to, content)\n    server.close()\n========================================']"
https://raw.githubusercontent.com/MinCiencia/ECQQ/f93a01ce2dd140d073bd81afb9b4733c1d8a34c3/superset-ecqq/RELEASING/send_email.py,"['sendmail', 'SMTP', 'login']","['Output sendmail:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================', 'Output SMTP:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================', 'Output SMTP:\ndef inter_send_email(username, password, sender_email, receiver_email, message):\n    print(""--------------------------"")\n    print(""SMTP Message"")\n    print(""--------------------------"")\n    print(message)\n    print(""--------------------------"")\n    confirm = input(""Is the Email message ok? (yes/no): "")\n    if confirm not in (""Yes"", ""yes"", ""y""):\n        exit(""Exit by user request"")\n\n    try:\n        send_email(\n            SMTP_SERVER,\n            SMTP_PORT,\n            username,\n            password,\n            sender_email,\n            receiver_email,\n            message,\n        )\n        print(""Email sent successfully"")\n    except smtplib.SMTPAuthenticationError:\n        exit(""SMTP User authentication error, Email not sent!"")\n    except Exception as e:\n        exit(f""SMTP exception {e}"")\n========================================', 'Output login:\ndef send_email(\n    smtp_server: str,\n    smpt_port: int,\n    username: str,\n    password: str,\n    sender_email: str,\n    receiver_email: str,\n    message: str,\n):\n    """"""\n    Send a simple text email (SMTP)\n    """"""\n    context = ssl.create_default_context()\n    with smtplib.SMTP(smtp_server, smpt_port) as server:\n        server.starttls(context=context)\n        server.login(username, password)\n        server.sendmail(sender_email, receiver_email, message)\n========================================']"
https://raw.githubusercontent.com/git-for-windows/git-sdk-32/04cbf0fa69bf5b065a811823360fc96a6e8c1d40/usr/lib/python3.9/smtplib.py,"['sendmail', 'SMTP', 'login']","['Output sendmail:\ndef sendmail(self, from_addr, to_addrs, msg, mail_options=(),\n                 rcpt_options=()):\n        """"""This command performs an entire mail transaction.\n\n        The arguments are:\n            - from_addr    : The address sending this mail.\n            - to_addrs     : A list of addresses to send this mail to.  A bare\n                             string will be treated as a list with 1 address.\n            - msg          : The message to send.\n            - mail_options : List of ESMTP options (such as 8bitmime) for the\n                             mail command.\n            - rcpt_options : List of ESMTP options (such as DSN commands) for\n                             all the rcpt commands.\n\n        msg may be a string containing characters in the ASCII range, or a byte\n        string.  A string is encoded to bytes using the ascii codec, and lone\n        \\\\r and \\\\n characters are converted to \\\\r\\\\n characters.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.  If the server does ESMTP, message size\n        and each of the specified options will be passed to it.  If EHLO\n        fails, HELO will be tried and ESMTP options suppressed.\n\n        This method will return normally if the mail is accepted for at least\n        one recipient.  It returns a dictionary, with one entry for each\n        recipient that was refused.  Each entry contains a tuple of the SMTP\n        error code and the accompanying error message sent by the server.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError          The server didn\'t reply properly to\n                                the helo greeting.\n         SMTPRecipientsRefused  The server rejected ALL recipients\n                                (no mail was sent).\n         SMTPSenderRefused      The server didn\'t accept the from_addr.\n         SMTPDataError          The server replied with an unexpected\n                                error code (other than a refusal of\n                                a recipient).\n         SMTPNotSupportedError  The mail_options parameter includes \'SMTPUTF8\'\n                                but the SMTPUTF8 extension is not supported by\n                                the server.\n\n        Note: the connection will be open even after an exception is raised.\n\n        Example:\n\n         >>> import smtplib\n         >>> s=smtplib.SMTP(""localhost"")\n         >>> tolist=[""one@one.org"",""two@two.org"",""three@three.org"",""four@four.org""]\n         >>> msg = \'\'\'\\\\\n         ... From: Me@my.org\n         ... Subject: testin\'...\n         ...\n         ... This is a test \'\'\'\n         >>> s.sendmail(""me@my.org"",tolist,msg)\n         { ""three@three.org"" : ( 550 ,""User unknown"" ) }\n         >>> s.quit()\n\n        In the above example, the message was accepted for delivery to three\n        of the four addresses, and one was rejected, with the error code\n        550.  If all addresses are accepted, then the method will return an\n        empty dictionary.\n\n        """"""\n        self.ehlo_or_helo_if_needed()\n        esmtp_opts = []\n        if isinstance(msg, str):\n            msg = _fix_eols(msg).encode(\'ascii\')\n        if self.does_esmtp:\n            if self.has_extn(\'size\'):\n                esmtp_opts.append(""size=%d"" % len(msg))\n            for option in mail_options:\n                esmtp_opts.append(option)\n        (code, resp) = self.mail(from_addr, esmtp_opts)\n        if code != 250:\n            if code == 421:\n                self.close()\n            else:\n                self._rset()\n            raise SMTPSenderRefused(code, resp, from_addr)\n        senderrs = {}\n        if isinstance(to_addrs, str):\n            to_addrs = [to_addrs]\n        for each in to_addrs:\n            (code, resp) = self.rcpt(each, rcpt_options)\n            if (code != 250) and (code != 251):\n                senderrs[each] = (code, resp)\n            if code == 421:\n                self.close()\n                raise SMTPRecipientsRefused(senderrs)\n        if len(senderrs) == len(to_addrs):\n            # the server refused all our recipients\n            self._rset()\n            raise SMTPRecipientsRefused(senderrs)\n        (code, resp) = self.data(msg)\n        if code != 250:\n            if code == 421:\n                self.close()\n            else:\n                self._rset()\n            raise SMTPDataError(code, resp)\n        #if we got here then somebody got our mail\n        return senderrs\n========================================', 'Output sendmail:\ndef send_message(self, msg, from_addr=None, to_addrs=None,\n                     mail_options=(), rcpt_options=()):\n        """"""Converts message to a bytestring and passes it to sendmail.\n\n        The arguments are as for sendmail, except that msg is an\n        email.message.Message object.  If from_addr is None or to_addrs is\n        None, these arguments are taken from the headers of the Message as\n        described in RFC 2822 (a ValueError is raised if there is more than\n        one set of \'Resent-\' headers).  Regardless of the values of from_addr and\n        to_addr, any Bcc field (or Resent-Bcc field, when the Message is a\n        resent) of the Message object won\'t be transmitted.  The Message\n        object is then serialized using email.generator.BytesGenerator and\n        sendmail is called to transmit the message.  If the sender or any of\n        the recipient addresses contain non-ASCII and the server advertises the\n        SMTPUTF8 capability, the policy is cloned with utf8 set to True for the\n        serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.\n        If the server does not support SMTPUTF8, an SMTPNotSupported error is\n        raised.  Otherwise the generator is called without modifying the\n        policy.\n\n        """"""\n        # \'Resent-Date\' is a mandatory field if the Message is resent (RFC 2822\n        # Section 3.6.6). In such a case, we use the \'Resent-*\' fields.  However,\n        # if there is more than one \'Resent-\' block there\'s no way to\n        # unambiguously determine which one is the most recent in all cases,\n        # so rather than guess we raise a ValueError in that case.\n        #\n        # TODO implement heuristics to guess the correct Resent-* block with an\n        # option allowing the user to enable the heuristics.  (It should be\n        # possible to guess correctly almost all of the time.)\n\n        self.ehlo_or_helo_if_needed()\n        resent = msg.get_all(\'Resent-Date\')\n        if resent is None:\n            header_prefix = \'\'\n        elif len(resent) == 1:\n            header_prefix = \'Resent-\'\n        else:\n            raise ValueError(""message has more than one \'Resent-\' header block"")\n        if from_addr is None:\n            # Prefer the sender field per RFC 2822:3.6.2.\n            from_addr = (msg[header_prefix + \'Sender\']\n                           if (header_prefix + \'Sender\') in msg\n                           else msg[header_prefix + \'From\'])\n            from_addr = email.utils.getaddresses([from_addr])[0][1]\n        if to_addrs is None:\n            addr_fields = [f for f in (msg[header_prefix + \'To\'],\n                                       msg[header_prefix + \'Bcc\'],\n                                       msg[header_prefix + \'Cc\'])\n                           if f is not None]\n            to_addrs = [a[1] for a in email.utils.getaddresses(addr_fields)]\n        # Make a local copy so we can delete the bcc headers.\n        msg_copy = copy.copy(msg)\n        del msg_copy[\'Bcc\']\n        del msg_copy[\'Resent-Bcc\']\n        international = False\n        try:\n            \'\'.join([from_addr, *to_addrs]).encode(\'ascii\')\n        except UnicodeEncodeError:\n            if not self.has_extn(\'smtputf8\'):\n                raise SMTPNotSupportedError(\n                    ""One or more source or delivery addresses require""\n                    "" internationalized email support, but the server""\n                    "" does not advertise the required SMTPUTF8 capability"")\n            international = True\n        with io.BytesIO() as bytesmsg:\n            if international:\n                g = email.generator.BytesGenerator(\n                    bytesmsg, policy=msg.policy.clone(utf8=True))\n                mail_options = (*mail_options, \'SMTPUTF8\', \'BODY=8BITMIME\')\n            else:\n                g = email.generator.BytesGenerator(bytesmsg)\n            g.flatten(msg_copy, linesep=\'\\r\\n\')\n            flatmsg = bytesmsg.getvalue()\n        return self.sendmail(from_addr, to_addrs, flatmsg, mail_options,\n                             rcpt_options)\n========================================', 'Output SMTP:\ndef __init__(self, host=\'\', port=0, local_hostname=None,\n                 timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n                 source_address=None):\n        """"""Initialize a new instance.\n\n        If specified, `host` is the name of the remote host to which to\n        connect.  If specified, `port` specifies the port to which to connect.\n        By default, smtplib.SMTP_PORT is used.  If a host is specified the\n        connect method is called, and if it returns anything other than a\n        success code an SMTPConnectError is raised.  If specified,\n        `local_hostname` is used as the FQDN of the local host in the HELO/EHLO\n        command.  Otherwise, the local hostname is found using\n        socket.getfqdn(). The `source_address` parameter takes a 2-tuple (host,\n        port) for the socket to bind to as its source address before\n        connecting. If the host is \'\' and port is 0, the OS default behavior\n        will be used.\n\n        """"""\n        self._host = host\n        self.timeout = timeout\n        self.esmtp_features = {}\n        self.command_encoding = \'ascii\'\n        self.source_address = source_address\n        self._auth_challenge_count = 0\n\n        if host:\n            (code, msg) = self.connect(host, port)\n            if code != 220:\n                self.close()\n                raise SMTPConnectError(code, msg)\n        if local_hostname is not None:\n            self.local_hostname = local_hostname\n        else:\n            # RFC 2821 says we should use the fqdn in the EHLO/HELO verb, and\n            # if that can\'t be calculated, that we should use a domain literal\n            # instead (essentially an encoded IP address like [A.B.C.D]).\n            fqdn = socket.getfqdn()\n            if \'.\' in fqdn:\n                self.local_hostname = fqdn\n            else:\n                # We can\'t find an fqdn hostname, so use a domain literal\n                addr = \'127.0.0.1\'\n                try:\n                    addr = socket.gethostbyname(socket.gethostname())\n                except socket.gaierror:\n                    pass\n                self.local_hostname = \'[%s]\' % addr\n========================================', 'Output SMTP:\ndef __exit__(self, *args):\n        try:\n            code, message = self.docmd(""QUIT"")\n            if code != 221:\n                raise SMTPResponseException(code, message)\n        except SMTPServerDisconnected:\n            pass\n        finally:\n            self.close()\n========================================', ""Output SMTP:\ndef _get_socket(self, host, port, timeout):\n        # This makes it simpler for SMTP_SSL to use the SMTP connect code\n        # and just alter the socket connection bit.\n        if timeout is not None and not timeout:\n            raise ValueError('Non-blocking socket (timeout=0) is not supported')\n        if self.debuglevel > 0:\n            self._print_debug('connect: to', (host, port), self.source_address)\n        return socket.create_connection((host, port), timeout,\n                                        self.source_address)\n========================================"", 'Output SMTP:\ndef send(self, s):\n        """"""Send `s\' to the server.""""""\n        if self.debuglevel > 0:\n            self._print_debug(\'send:\', repr(s))\n        if self.sock:\n            if isinstance(s, str):\n                # send is used by the \'data\' command, where command_encoding\n                # should not be used, but \'data\' needs to convert the string to\n                # binary itself anyway, so that\'s not a problem.\n                s = s.encode(self.command_encoding)\n            sys.audit(""smtplib.send"", self, s)\n            try:\n                self.sock.sendall(s)\n            except OSError:\n                self.close()\n                raise SMTPServerDisconnected(\'Server not connected\')\n        else:\n            raise SMTPServerDisconnected(\'please run connect() first\')\n========================================', 'Output SMTP:\ndef getreply(self):\n        """"""Get a reply from the server.\n\n        Returns a tuple consisting of:\n\n          - server response code (e.g. \'250\', or such, if all goes well)\n            Note: returns -1 if it can\'t read response code.\n\n          - server response string corresponding to response code (multiline\n            responses are converted to a single, multiline string).\n\n        Raises SMTPServerDisconnected if end-of-file is reached.\n        """"""\n        resp = []\n        if self.file is None:\n            self.file = self.sock.makefile(\'rb\')\n        while 1:\n            try:\n                line = self.file.readline(_MAXLINE + 1)\n            except OSError as e:\n                self.close()\n                raise SMTPServerDisconnected(""Connection unexpectedly closed: ""\n                                             + str(e))\n            if not line:\n                self.close()\n                raise SMTPServerDisconnected(""Connection unexpectedly closed"")\n            if self.debuglevel > 0:\n                self._print_debug(\'reply:\', repr(line))\n            if len(line) > _MAXLINE:\n                self.close()\n                raise SMTPResponseException(500, ""Line too long."")\n            resp.append(line[4:].strip(b\' \\t\\r\\n\'))\n            code = line[:3]\n            # Check that the error code is syntactically correct.\n            # Don\'t attempt to read a continuation line if it is broken.\n            try:\n                errcode = int(code)\n            except ValueError:\n                errcode = -1\n                break\n            # Check if multiline response.\n            if line[3:4] != b""-"":\n                break\n\n        errmsg = b""\\n"".join(resp)\n        if self.debuglevel > 0:\n            self._print_debug(\'reply: retcode (%s); Msg: %a\' % (errcode, errmsg))\n        return errcode, errmsg\n========================================', 'Output SMTP:\ndef helo(self, name=\'\'):\n        """"""SMTP \'helo\' command.\n        Hostname to send for this command defaults to the FQDN of the local\n        host.\n        """"""\n        self.putcmd(""helo"", name or self.local_hostname)\n        (code, msg) = self.getreply()\n        self.helo_resp = msg\n        return (code, msg)\n========================================', 'Output SMTP:\ndef ehlo(self, name=\'\'):\n        """""" SMTP \'ehlo\' command.\n        Hostname to send for this command defaults to the FQDN of the local\n        host.\n        """"""\n        self.esmtp_features = {}\n        self.putcmd(self.ehlo_msg, name or self.local_hostname)\n        (code, msg) = self.getreply()\n        # According to RFC1869 some (badly written)\n        # MTA\'s will disconnect on an ehlo. Toss an exception if\n        # that happens -ddm\n        if code == -1 and len(msg) == 0:\n            self.close()\n            raise SMTPServerDisconnected(""Server not connected"")\n        self.ehlo_resp = msg\n        if code != 250:\n            return (code, msg)\n        self.does_esmtp = 1\n        #parse the ehlo response -ddm\n        assert isinstance(self.ehlo_resp, bytes), repr(self.ehlo_resp)\n        resp = self.ehlo_resp.decode(""latin-1"").split(\'\\n\')\n        del resp[0]\n        for each in resp:\n            # To be able to communicate with as many SMTP servers as possible,\n            # we have to take the old-style auth advertisement into account,\n            # because:\n            # 1) Else our SMTP feature parser gets confused.\n            # 2) There are some servers that only advertise the auth methods we\n            #    support using the old style.\n            auth_match = OLDSTYLE_AUTH.match(each)\n            if auth_match:\n                # This doesn\'t remove duplicates, but that\'s no problem\n                self.esmtp_features[""auth""] = self.esmtp_features.get(""auth"", """") \\\n                        + "" "" + auth_match.groups(0)[0]\n                continue\n\n            # RFC 1869 requires a space between ehlo keyword and parameters.\n            # It\'s actually stricter, in that only spaces are allowed between\n            # parameters, but were not going to check for that here.  Note\n            # that the space isn\'t present if there are no parameters.\n            m = re.match(r\'(?P<feature>[A-Za-z0-9][A-Za-z0-9\\-]*) ?\', each)\n            if m:\n                feature = m.group(""feature"").lower()\n                params = m.string[m.end(""feature""):].strip()\n                if feature == ""auth"":\n                    self.esmtp_features[feature] = self.esmtp_features.get(feature, """") \\\n                            + "" "" + params\n                else:\n                    self.esmtp_features[feature] = params\n        return (code, msg)\n========================================', 'Output SMTP:\ndef has_extn(self, opt):\n        """"""Does the server support a given SMTP service extension?""""""\n        return opt.lower() in self.esmtp_features\n========================================', 'Output SMTP:\ndef help(self, args=\'\'):\n        """"""SMTP \'help\' command.\n        Returns help text from server.""""""\n        self.putcmd(""help"", args)\n        return self.getreply()[1]\n========================================', 'Output SMTP:\ndef rset(self):\n        """"""SMTP \'rset\' command -- resets session.""""""\n        self.command_encoding = \'ascii\'\n        return self.docmd(""rset"")\n========================================', 'Output SMTP:\ndef _rset(self):\n        """"""Internal \'rset\' command which ignores any SMTPServerDisconnected error.\n\n        Used internally in the library, since the server disconnected error\n        should appear to the application when the *next* command is issued, if\n        we are doing an internal ""safety"" reset.\n        """"""\n        try:\n            self.rset()\n        except SMTPServerDisconnected:\n            pass\n========================================', 'Output SMTP:\ndef noop(self):\n        """"""SMTP \'noop\' command -- doesn\'t do anything :>""""""\n        return self.docmd(""noop"")\n========================================', 'Output SMTP:\ndef mail(self, sender, options=()):\n        """"""SMTP \'mail\' command -- begins mail xfer session.\n\n        This method may raise the following exceptions:\n\n         SMTPNotSupportedError  The options parameter includes \'SMTPUTF8\'\n                                but the SMTPUTF8 extension is not supported by\n                                the server.\n        """"""\n        optionlist = \'\'\n        if options and self.does_esmtp:\n            if any(x.lower()==\'smtputf8\' for x in options):\n                if self.has_extn(\'smtputf8\'):\n                    self.command_encoding = \'utf-8\'\n                else:\n                    raise SMTPNotSupportedError(\n                        \'SMTPUTF8 not supported by server\')\n            optionlist = \' \' + \' \'.join(options)\n        self.putcmd(""mail"", ""FROM:%s%s"" % (quoteaddr(sender), optionlist))\n        return self.getreply()\n========================================', 'Output SMTP:\ndef rcpt(self, recip, options=()):\n        """"""SMTP \'rcpt\' command -- indicates 1 recipient for this mail.""""""\n        optionlist = \'\'\n        if options and self.does_esmtp:\n            optionlist = \' \' + \' \'.join(options)\n        self.putcmd(""rcpt"", ""TO:%s%s"" % (quoteaddr(recip), optionlist))\n        return self.getreply()\n========================================', 'Output SMTP:\ndef data(self, msg):\n        """"""SMTP \'DATA\' command -- sends message data to server.\n\n        Automatically quotes lines beginning with a period per rfc821.\n        Raises SMTPDataError if there is an unexpected reply to the\n        DATA command; the return value from this method is the final\n        response code received when the all data is sent.  If msg\n        is a string, lone \'\\\\r\' and \'\\\\n\' characters are converted to\n        \'\\\\r\\\\n\' characters.  If msg is bytes, it is transmitted as is.\n        """"""\n        self.putcmd(""data"")\n        (code, repl) = self.getreply()\n        if self.debuglevel > 0:\n            self._print_debug(\'data:\', (code, repl))\n        if code != 354:\n            raise SMTPDataError(code, repl)\n        else:\n            if isinstance(msg, str):\n                msg = _fix_eols(msg).encode(\'ascii\')\n            q = _quote_periods(msg)\n            if q[-2:] != bCRLF:\n                q = q + bCRLF\n            q = q + b""."" + bCRLF\n            self.send(q)\n            (code, msg) = self.getreply()\n            if self.debuglevel > 0:\n                self._print_debug(\'data:\', (code, msg))\n            return (code, msg)\n========================================', 'Output SMTP:\ndef verify(self, address):\n        """"""SMTP \'verify\' command -- checks for address validity.""""""\n        self.putcmd(""vrfy"", _addr_only(address))\n        return self.getreply()\n========================================', 'Output SMTP:\ndef expn(self, address):\n        """"""SMTP \'expn\' command -- expands a mailing list.""""""\n        self.putcmd(""expn"", _addr_only(address))\n        return self.getreply()\n========================================', 'Output SMTP:\ndef ehlo_or_helo_if_needed(self):\n        """"""Call self.ehlo() and/or self.helo() if needed.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError            The server didn\'t reply properly to\n                                  the helo greeting.\n        """"""\n        if self.helo_resp is None and self.ehlo_resp is None:\n            if not (200 <= self.ehlo()[0] <= 299):\n                (code, resp) = self.helo()\n                if not (200 <= code <= 299):\n                    raise SMTPHeloError(code, resp)\n========================================', 'Output SMTP:\ndef auth(self, mechanism, authobject, *, initial_response_ok=True):\n        """"""Authentication command - requires response processing.\n\n        \'mechanism\' specifies which authentication mechanism is to\n        be used - the valid values are those listed in the \'auth\'\n        element of \'esmtp_features\'.\n\n        \'authobject\' must be a callable object taking a single argument:\n\n                data = authobject(challenge)\n\n        It will be called to process the server\'s challenge response; the\n        challenge argument it is passed will be a bytes.  It should return\n        an ASCII string that will be base64 encoded and sent to the server.\n\n        Keyword arguments:\n            - initial_response_ok: Allow sending the RFC 4954 initial-response\n              to the AUTH command, if the authentication methods supports it.\n        """"""\n        # RFC 4954 allows auth methods to provide an initial response.  Not all\n        # methods support it.  By definition, if they return something other\n        # than None when challenge is None, then they do.  See issue #15014.\n        mechanism = mechanism.upper()\n        initial_response = (authobject() if initial_response_ok else None)\n        if initial_response is not None:\n            response = encode_base64(initial_response.encode(\'ascii\'), eol=\'\')\n            (code, resp) = self.docmd(""AUTH"", mechanism + "" "" + response)\n            self._auth_challenge_count = 1\n        else:\n            (code, resp) = self.docmd(""AUTH"", mechanism)\n            self._auth_challenge_count = 0\n        # If server responds with a challenge, send the response.\n        while code == 334:\n            self._auth_challenge_count += 1\n            challenge = base64.decodebytes(resp)\n            response = encode_base64(\n                authobject(challenge).encode(\'ascii\'), eol=\'\')\n            (code, resp) = self.docmd(response)\n            # If server keeps sending challenges, something is wrong.\n            if self._auth_challenge_count > _MAXCHALLENGE:\n                raise SMTPException(\n                    ""Server AUTH mechanism infinite loop. Last response: ""\n                    + repr((code, resp))\n                )\n        if code in (235, 503):\n            return (code, resp)\n        raise SMTPAuthenticationError(code, resp)\n========================================', 'Output SMTP:\ndef login(self, user, password, *, initial_response_ok=True):\n        """"""Log in on an SMTP server that requires authentication.\n\n        The arguments are:\n            - user:         The user name to authenticate with.\n            - password:     The password for the authentication.\n\n        Keyword arguments:\n            - initial_response_ok: Allow sending the RFC 4954 initial-response\n              to the AUTH command, if the authentication methods supports it.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n\n        This method will return normally if the authentication was successful.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError            The server didn\'t reply properly to\n                                  the helo greeting.\n         SMTPAuthenticationError  The server didn\'t accept the username/\n                                  password combination.\n         SMTPNotSupportedError    The AUTH command is not supported by the\n                                  server.\n         SMTPException            No suitable authentication method was\n                                  found.\n        """"""\n\n        self.ehlo_or_helo_if_needed()\n        if not self.has_extn(""auth""):\n            raise SMTPNotSupportedError(\n                ""SMTP AUTH extension not supported by server."")\n\n        # Authentication methods the server claims to support\n        advertised_authlist = self.esmtp_features[""auth""].split()\n\n        # Authentication methods we can handle in our preferred order:\n        preferred_auths = [\'CRAM-MD5\', \'PLAIN\', \'LOGIN\']\n\n        # We try the supported authentications in our preferred order, if\n        # the server supports them.\n        authlist = [auth for auth in preferred_auths\n                    if auth in advertised_authlist]\n        if not authlist:\n            raise SMTPException(""No suitable authentication method found."")\n\n        # Some servers advertise authentication methods they don\'t really\n        # support, so if authentication fails, we continue until we\'ve tried\n        # all methods.\n        self.user, self.password = user, password\n        for authmethod in authlist:\n            method_name = \'auth_\' + authmethod.lower().replace(\'-\', \'_\')\n            try:\n                (code, resp) = self.auth(\n                    authmethod, getattr(self, method_name),\n                    initial_response_ok=initial_response_ok)\n                # 235 == \'Authentication successful\'\n                # 503 == \'Error: already authenticated\'\n                if code in (235, 503):\n                    return (code, resp)\n            except SMTPAuthenticationError as e:\n                last_exception = e\n\n        # We could not login successfully.  Return result of last attempt.\n        raise last_exception\n========================================', 'Output SMTP:\ndef starttls(self, keyfile=None, certfile=None, context=None):\n        """"""Puts the connection to the SMTP server into TLS mode.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n\n        If the server supports TLS, this will encrypt the rest of the SMTP\n        session. If you provide the keyfile and certfile parameters,\n        the identity of the SMTP server and client can be checked. This,\n        however, depends on whether the socket module really checks the\n        certificates.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError            The server didn\'t reply properly to\n                                  the helo greeting.\n        """"""\n        self.ehlo_or_helo_if_needed()\n        if not self.has_extn(""starttls""):\n            raise SMTPNotSupportedError(\n                ""STARTTLS extension not supported by server."")\n        (resp, reply) = self.docmd(""STARTTLS"")\n        if resp == 220:\n            if not _have_ssl:\n                raise RuntimeError(""No SSL support included in this Python"")\n            if context is not None and keyfile is not None:\n                raise ValueError(""context and keyfile arguments are mutually ""\n                                 ""exclusive"")\n            if context is not None and certfile is not None:\n                raise ValueError(""context and certfile arguments are mutually ""\n                                 ""exclusive"")\n            if keyfile is not None or certfile is not None:\n                import warnings\n                warnings.warn(""keyfile and certfile are deprecated, use a ""\n                              ""custom context instead"", DeprecationWarning, 2)\n            if context is None:\n                context = ssl._create_stdlib_context(certfile=certfile,\n                                                     keyfile=keyfile)\n            self.sock = context.wrap_socket(self.sock,\n                                            server_hostname=self._host)\n            self.file = None\n            # RFC 3207:\n            # The client MUST discard any knowledge obtained from\n            # the server, such as the list of SMTP service extensions,\n            # which was not obtained from the TLS negotiation itself.\n            self.helo_resp = None\n            self.ehlo_resp = None\n            self.esmtp_features = {}\n            self.does_esmtp = 0\n        else:\n            # RFC 3207:\n            # 501 Syntax error (no parameters allowed)\n            # 454 TLS not available due to temporary reason\n            raise SMTPResponseException(resp, reply)\n        return (resp, reply)\n========================================', 'Output SMTP:\ndef sendmail(self, from_addr, to_addrs, msg, mail_options=(),\n                 rcpt_options=()):\n        """"""This command performs an entire mail transaction.\n\n        The arguments are:\n            - from_addr    : The address sending this mail.\n            - to_addrs     : A list of addresses to send this mail to.  A bare\n                             string will be treated as a list with 1 address.\n            - msg          : The message to send.\n            - mail_options : List of ESMTP options (such as 8bitmime) for the\n                             mail command.\n            - rcpt_options : List of ESMTP options (such as DSN commands) for\n                             all the rcpt commands.\n\n        msg may be a string containing characters in the ASCII range, or a byte\n        string.  A string is encoded to bytes using the ascii codec, and lone\n        \\\\r and \\\\n characters are converted to \\\\r\\\\n characters.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.  If the server does ESMTP, message size\n        and each of the specified options will be passed to it.  If EHLO\n        fails, HELO will be tried and ESMTP options suppressed.\n\n        This method will return normally if the mail is accepted for at least\n        one recipient.  It returns a dictionary, with one entry for each\n        recipient that was refused.  Each entry contains a tuple of the SMTP\n        error code and the accompanying error message sent by the server.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError          The server didn\'t reply properly to\n                                the helo greeting.\n         SMTPRecipientsRefused  The server rejected ALL recipients\n                                (no mail was sent).\n         SMTPSenderRefused      The server didn\'t accept the from_addr.\n         SMTPDataError          The server replied with an unexpected\n                                error code (other than a refusal of\n                                a recipient).\n         SMTPNotSupportedError  The mail_options parameter includes \'SMTPUTF8\'\n                                but the SMTPUTF8 extension is not supported by\n                                the server.\n\n        Note: the connection will be open even after an exception is raised.\n\n        Example:\n\n         >>> import smtplib\n         >>> s=smtplib.SMTP(""localhost"")\n         >>> tolist=[""one@one.org"",""two@two.org"",""three@three.org"",""four@four.org""]\n         >>> msg = \'\'\'\\\\\n         ... From: Me@my.org\n         ... Subject: testin\'...\n         ...\n         ... This is a test \'\'\'\n         >>> s.sendmail(""me@my.org"",tolist,msg)\n         { ""three@three.org"" : ( 550 ,""User unknown"" ) }\n         >>> s.quit()\n\n        In the above example, the message was accepted for delivery to three\n        of the four addresses, and one was rejected, with the error code\n        550.  If all addresses are accepted, then the method will return an\n        empty dictionary.\n\n        """"""\n        self.ehlo_or_helo_if_needed()\n        esmtp_opts = []\n        if isinstance(msg, str):\n            msg = _fix_eols(msg).encode(\'ascii\')\n        if self.does_esmtp:\n            if self.has_extn(\'size\'):\n                esmtp_opts.append(""size=%d"" % len(msg))\n            for option in mail_options:\n                esmtp_opts.append(option)\n        (code, resp) = self.mail(from_addr, esmtp_opts)\n        if code != 250:\n            if code == 421:\n                self.close()\n            else:\n                self._rset()\n            raise SMTPSenderRefused(code, resp, from_addr)\n        senderrs = {}\n        if isinstance(to_addrs, str):\n            to_addrs = [to_addrs]\n        for each in to_addrs:\n            (code, resp) = self.rcpt(each, rcpt_options)\n            if (code != 250) and (code != 251):\n                senderrs[each] = (code, resp)\n            if code == 421:\n                self.close()\n                raise SMTPRecipientsRefused(senderrs)\n        if len(senderrs) == len(to_addrs):\n            # the server refused all our recipients\n            self._rset()\n            raise SMTPRecipientsRefused(senderrs)\n        (code, resp) = self.data(msg)\n        if code != 250:\n            if code == 421:\n                self.close()\n            else:\n                self._rset()\n            raise SMTPDataError(code, resp)\n        #if we got here then somebody got our mail\n        return senderrs\n========================================', 'Output SMTP:\ndef send_message(self, msg, from_addr=None, to_addrs=None,\n                     mail_options=(), rcpt_options=()):\n        """"""Converts message to a bytestring and passes it to sendmail.\n\n        The arguments are as for sendmail, except that msg is an\n        email.message.Message object.  If from_addr is None or to_addrs is\n        None, these arguments are taken from the headers of the Message as\n        described in RFC 2822 (a ValueError is raised if there is more than\n        one set of \'Resent-\' headers).  Regardless of the values of from_addr and\n        to_addr, any Bcc field (or Resent-Bcc field, when the Message is a\n        resent) of the Message object won\'t be transmitted.  The Message\n        object is then serialized using email.generator.BytesGenerator and\n        sendmail is called to transmit the message.  If the sender or any of\n        the recipient addresses contain non-ASCII and the server advertises the\n        SMTPUTF8 capability, the policy is cloned with utf8 set to True for the\n        serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.\n        If the server does not support SMTPUTF8, an SMTPNotSupported error is\n        raised.  Otherwise the generator is called without modifying the\n        policy.\n\n        """"""\n        # \'Resent-Date\' is a mandatory field if the Message is resent (RFC 2822\n        # Section 3.6.6). In such a case, we use the \'Resent-*\' fields.  However,\n        # if there is more than one \'Resent-\' block there\'s no way to\n        # unambiguously determine which one is the most recent in all cases,\n        # so rather than guess we raise a ValueError in that case.\n        #\n        # TODO implement heuristics to guess the correct Resent-* block with an\n        # option allowing the user to enable the heuristics.  (It should be\n        # possible to guess correctly almost all of the time.)\n\n        self.ehlo_or_helo_if_needed()\n        resent = msg.get_all(\'Resent-Date\')\n        if resent is None:\n            header_prefix = \'\'\n        elif len(resent) == 1:\n            header_prefix = \'Resent-\'\n        else:\n            raise ValueError(""message has more than one \'Resent-\' header block"")\n        if from_addr is None:\n            # Prefer the sender field per RFC 2822:3.6.2.\n            from_addr = (msg[header_prefix + \'Sender\']\n                           if (header_prefix + \'Sender\') in msg\n                           else msg[header_prefix + \'From\'])\n            from_addr = email.utils.getaddresses([from_addr])[0][1]\n        if to_addrs is None:\n            addr_fields = [f for f in (msg[header_prefix + \'To\'],\n                                       msg[header_prefix + \'Bcc\'],\n                                       msg[header_prefix + \'Cc\'])\n                           if f is not None]\n            to_addrs = [a[1] for a in email.utils.getaddresses(addr_fields)]\n        # Make a local copy so we can delete the bcc headers.\n        msg_copy = copy.copy(msg)\n        del msg_copy[\'Bcc\']\n        del msg_copy[\'Resent-Bcc\']\n        international = False\n        try:\n            \'\'.join([from_addr, *to_addrs]).encode(\'ascii\')\n        except UnicodeEncodeError:\n            if not self.has_extn(\'smtputf8\'):\n                raise SMTPNotSupportedError(\n                    ""One or more source or delivery addresses require""\n                    "" internationalized email support, but the server""\n                    "" does not advertise the required SMTPUTF8 capability"")\n            international = True\n        with io.BytesIO() as bytesmsg:\n            if international:\n                g = email.generator.BytesGenerator(\n                    bytesmsg, policy=msg.policy.clone(utf8=True))\n                mail_options = (*mail_options, \'SMTPUTF8\', \'BODY=8BITMIME\')\n            else:\n                g = email.generator.BytesGenerator(bytesmsg)\n            g.flatten(msg_copy, linesep=\'\\r\\n\')\n            flatmsg = bytesmsg.getvalue()\n        return self.sendmail(from_addr, to_addrs, flatmsg, mail_options,\n                             rcpt_options)\n========================================', 'Output SMTP:\ndef close(self):\n        """"""Close the connection to the SMTP server.""""""\n        try:\n            file = self.file\n            self.file = None\n            if file:\n                file.close()\n        finally:\n            sock = self.sock\n            self.sock = None\n            if sock:\n                sock.close()\n========================================', 'Output SMTP:\ndef quit(self):\n        """"""Terminate the SMTP session.""""""\n        res = self.docmd(""quit"")\n        # A new EHLO is required after reconnecting with connect()\n        self.ehlo_resp = self.helo_resp = None\n        self.esmtp_features = {}\n        self.does_esmtp = False\n        self.close()\n        return res\n========================================', 'Output SMTP:\ndef __init__(self, host=\'\', port=0, local_hostname=None,\n                     keyfile=None, certfile=None,\n                     timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n                     source_address=None, context=None):\n            if context is not None and keyfile is not None:\n                raise ValueError(""context and keyfile arguments are mutually ""\n                                 ""exclusive"")\n            if context is not None and certfile is not None:\n                raise ValueError(""context and certfile arguments are mutually ""\n                                 ""exclusive"")\n            if keyfile is not None or certfile is not None:\n                import warnings\n                warnings.warn(""keyfile and certfile are deprecated, use a ""\n                              ""custom context instead"", DeprecationWarning, 2)\n            self.keyfile = keyfile\n            self.certfile = certfile\n            if context is None:\n                context = ssl._create_stdlib_context(certfile=certfile,\n                                                     keyfile=keyfile)\n            self.context = context\n            SMTP.__init__(self, host, port, local_hostname, timeout,\n                          source_address)\n========================================', 'Output login:\ndef auth_login(self, challenge=None):\n        """""" Authobject to use with LOGIN authentication. Requires self.user and\n        self.password to be set.""""""\n        if challenge is None or self._auth_challenge_count < 2:\n            return self.user\n        else:\n            return self.password\n========================================', 'Output login:\ndef login(self, user, password, *, initial_response_ok=True):\n        """"""Log in on an SMTP server that requires authentication.\n\n        The arguments are:\n            - user:         The user name to authenticate with.\n            - password:     The password for the authentication.\n\n        Keyword arguments:\n            - initial_response_ok: Allow sending the RFC 4954 initial-response\n              to the AUTH command, if the authentication methods supports it.\n\n        If there has been no previous EHLO or HELO command this session, this\n        method tries ESMTP EHLO first.\n\n        This method will return normally if the authentication was successful.\n\n        This method may raise the following exceptions:\n\n         SMTPHeloError            The server didn\'t reply properly to\n                                  the helo greeting.\n         SMTPAuthenticationError  The server didn\'t accept the username/\n                                  password combination.\n         SMTPNotSupportedError    The AUTH command is not supported by the\n                                  server.\n         SMTPException            No suitable authentication method was\n                                  found.\n        """"""\n\n        self.ehlo_or_helo_if_needed()\n        if not self.has_extn(""auth""):\n            raise SMTPNotSupportedError(\n                ""SMTP AUTH extension not supported by server."")\n\n        # Authentication methods the server claims to support\n        advertised_authlist = self.esmtp_features[""auth""].split()\n\n        # Authentication methods we can handle in our preferred order:\n        preferred_auths = [\'CRAM-MD5\', \'PLAIN\', \'LOGIN\']\n\n        # We try the supported authentications in our preferred order, if\n        # the server supports them.\n        authlist = [auth for auth in preferred_auths\n                    if auth in advertised_authlist]\n        if not authlist:\n            raise SMTPException(""No suitable authentication method found."")\n\n        # Some servers advertise authentication methods they don\'t really\n        # support, so if authentication fails, we continue until we\'ve tried\n        # all methods.\n        self.user, self.password = user, password\n        for authmethod in authlist:\n            method_name = \'auth_\' + authmethod.lower().replace(\'-\', \'_\')\n            try:\n                (code, resp) = self.auth(\n                    authmethod, getattr(self, method_name),\n                    initial_response_ok=initial_response_ok)\n                # 235 == \'Authentication successful\'\n                # 503 == \'Error: already authenticated\'\n                if code in (235, 503):\n                    return (code, resp)\n            except SMTPAuthenticationError as e:\n                last_exception = e\n\n        # We could not login successfully.  Return result of last attempt.\n        raise last_exception\n========================================']"
https://raw.githubusercontent.com/geekcomputers/Python/96d0eb61826cbd1e88251e8bb5237a009d0b5a10/sendemail.py,"['MIMEText', 'MIMEMultipart']","['Output MIMEText:\ndef createMessageWithAttachment(sender, to, subject, msgHtml, msgPlain, attachmentFile):\n    """"""Create a message for an email.\n\n    Args:\n        sender: Email address of the sender.\n        to: Email address of the receiver.\n        subject: The subject of the email message.\n        msgHtml: Html message to be sent\n        msgPlain: Alternative plain text message for older email clients\n        attachmentFile: The path to the file to be attached.\n\n    Returns:\n        An object containing a base64url encoded email object.\n    """"""\n    message = MIMEMultipart(""mixed"")\n    message[""to""] = to\n    message[""from""] = sender\n    message[""subject""] = subject\n\n    messageA = MIMEMultipart(""alternative"")\n    messageR = MIMEMultipart(""related"")\n\n    messageR.attach(MIMEText(msgHtml, ""html""))\n    messageA.attach(MIMEText(msgPlain, ""plain""))\n    messageA.attach(messageR)\n\n    message.attach(messageA)\n\n    print(""create_message_with_attachment: file:"", attachmentFile)\n    content_type, encoding = mimetypes.guess_type(attachmentFile)\n\n    if content_type is None or encoding is not None:\n        content_type = ""application/octet-stream""\n    main_type, sub_type = content_type.split(""/"", 1)\n    if main_type == ""text"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEText(fp.read(), _subtype=sub_type)\n        fp.close()\n    elif main_type == ""image"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEImage(fp.read(), _subtype=sub_type)\n        fp.close()\n    elif main_type == ""audio"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEAudio(fp.read(), _subtype=sub_type)\n        fp.close()\n    else:\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEBase(main_type, sub_type)\n        msg.set_payload(fp.read())\n        fp.close()\n    filename = os.path.basename(attachmentFile)\n    msg.add_header(""Content-Disposition"", ""attachment"", filename=filename)\n    message.attach(msg)\n\n    return {""raw"": base64.urlsafe_b64encode(message.as_string())}\n========================================', 'Output MIMEText:\ndef CreateMessageHtml(sender, to, subject, msgHtml, msgPlain):\n    msg = MIMEMultipart(""alternative"")\n    msg[""Subject""] = subject\n    msg[""From""] = sender\n    msg[""To""] = to\n    msg.attach(MIMEText(msgPlain, ""plain""))\n    msg.attach(MIMEText(msgHtml, ""html""))\n    return {""raw"": base64.urlsafe_b64encode(msg.as_string())}\n========================================', 'Output MIMEMultipart:\ndef createMessageWithAttachment(sender, to, subject, msgHtml, msgPlain, attachmentFile):\n    """"""Create a message for an email.\n\n    Args:\n        sender: Email address of the sender.\n        to: Email address of the receiver.\n        subject: The subject of the email message.\n        msgHtml: Html message to be sent\n        msgPlain: Alternative plain text message for older email clients\n        attachmentFile: The path to the file to be attached.\n\n    Returns:\n        An object containing a base64url encoded email object.\n    """"""\n    message = MIMEMultipart(""mixed"")\n    message[""to""] = to\n    message[""from""] = sender\n    message[""subject""] = subject\n\n    messageA = MIMEMultipart(""alternative"")\n    messageR = MIMEMultipart(""related"")\n\n    messageR.attach(MIMEText(msgHtml, ""html""))\n    messageA.attach(MIMEText(msgPlain, ""plain""))\n    messageA.attach(messageR)\n\n    message.attach(messageA)\n\n    print(""create_message_with_attachment: file:"", attachmentFile)\n    content_type, encoding = mimetypes.guess_type(attachmentFile)\n\n    if content_type is None or encoding is not None:\n        content_type = ""application/octet-stream""\n    main_type, sub_type = content_type.split(""/"", 1)\n    if main_type == ""text"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEText(fp.read(), _subtype=sub_type)\n        fp.close()\n    elif main_type == ""image"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEImage(fp.read(), _subtype=sub_type)\n        fp.close()\n    elif main_type == ""audio"":\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEAudio(fp.read(), _subtype=sub_type)\n        fp.close()\n    else:\n        fp = open(attachmentFile, ""rb"")\n        msg = MIMEBase(main_type, sub_type)\n        msg.set_payload(fp.read())\n        fp.close()\n    filename = os.path.basename(attachmentFile)\n    msg.add_header(""Content-Disposition"", ""attachment"", filename=filename)\n    message.attach(msg)\n\n    return {""raw"": base64.urlsafe_b64encode(message.as_string())}\n========================================', 'Output MIMEMultipart:\ndef CreateMessageHtml(sender, to, subject, msgHtml, msgPlain):\n    msg = MIMEMultipart(""alternative"")\n    msg[""Subject""] = subject\n    msg[""From""] = sender\n    msg[""To""] = to\n    msg.attach(MIMEText(msgPlain, ""plain""))\n    msg.attach(MIMEText(msgHtml, ""html""))\n    return {""raw"": base64.urlsafe_b64encode(msg.as_string())}\n========================================']"
https://raw.githubusercontent.com/scrapy/scrapy/6587556af9ba92cd1f73ea2ed172a513bf80e6a5/scrapy/mail.py,"['MIMEText', 'sendmail', 'SMTP', 'MIMEMultipart']","['Output MIMEText:\ndef send(\n        self,\n        to,\n        subject,\n        body,\n        cc=None,\n        attachs=(),\n        mimetype=""text/plain"",\n        charset=None,\n        _callback=None,\n    ):\n        from twisted.internet import reactor\n\n        if attachs:\n            msg = MIMEMultipart()\n        else:\n            msg = MIMENonMultipart(*mimetype.split(""/"", 1))\n\n        to = list(arg_to_iter(to))\n        cc = list(arg_to_iter(cc))\n\n        msg[""From""] = self.mailfrom\n        msg[""To""] = COMMASPACE.join(to)\n        msg[""Date""] = formatdate(localtime=True)\n        msg[""Subject""] = subject\n        rcpts = to[:]\n        if cc:\n            rcpts.extend(cc)\n            msg[""Cc""] = COMMASPACE.join(cc)\n\n        if attachs:\n            if charset:\n                msg.set_charset(charset)\n            msg.attach(MIMEText(body, ""plain"", charset or ""us-ascii""))\n            for attach_name, mimetype, f in attachs:\n                part = MIMEBase(*mimetype.split(""/""))\n                part.set_payload(f.read())\n                Encoders.encode_base64(part)\n                part.add_header(\n                    ""Content-Disposition"", ""attachment"", filename=attach_name\n                )\n                msg.attach(part)\n        else:\n            msg.set_payload(body, charset)\n\n        if _callback:\n            _callback(to=to, subject=subject, body=body, cc=cc, attach=attachs, msg=msg)\n\n        if self.debug:\n            logger.debug(\n                ""Debug mail sent OK: To=%(mailto)s Cc=%(mailcc)s ""\n                \'Subject=""%(mailsubject)s"" Attachs=%(mailattachs)d\',\n                {\n                    ""mailto"": to,\n                    ""mailcc"": cc,\n                    ""mailsubject"": subject,\n                    ""mailattachs"": len(attachs),\n                },\n            )\n            return\n\n        dfd = self._sendmail(rcpts, msg.as_string().encode(charset or ""utf-8""))\n        dfd.addCallbacks(\n            callback=self._sent_ok,\n            errback=self._sent_failed,\n            callbackArgs=[to, cc, subject, len(attachs)],\n            errbackArgs=[to, cc, subject, len(attachs)],\n        )\n        reactor.addSystemEventTrigger(""before"", ""shutdown"", lambda: dfd)\n        return dfd\n========================================', 'Output sendmail:\ndef send(\n        self,\n        to,\n        subject,\n        body,\n        cc=None,\n        attachs=(),\n        mimetype=""text/plain"",\n        charset=None,\n        _callback=None,\n    ):\n        from twisted.internet import reactor\n\n        if attachs:\n            msg = MIMEMultipart()\n        else:\n            msg = MIMENonMultipart(*mimetype.split(""/"", 1))\n\n        to = list(arg_to_iter(to))\n        cc = list(arg_to_iter(cc))\n\n        msg[""From""] = self.mailfrom\n        msg[""To""] = COMMASPACE.join(to)\n        msg[""Date""] = formatdate(localtime=True)\n        msg[""Subject""] = subject\n        rcpts = to[:]\n        if cc:\n            rcpts.extend(cc)\n            msg[""Cc""] = COMMASPACE.join(cc)\n\n        if attachs:\n            if charset:\n                msg.set_charset(charset)\n            msg.attach(MIMEText(body, ""plain"", charset or ""us-ascii""))\n            for attach_name, mimetype, f in attachs:\n                part = MIMEBase(*mimetype.split(""/""))\n                part.set_payload(f.read())\n                Encoders.encode_base64(part)\n                part.add_header(\n                    ""Content-Disposition"", ""attachment"", filename=attach_name\n                )\n                msg.attach(part)\n        else:\n            msg.set_payload(body, charset)\n\n        if _callback:\n            _callback(to=to, subject=subject, body=body, cc=cc, attach=attachs, msg=msg)\n\n        if self.debug:\n            logger.debug(\n                ""Debug mail sent OK: To=%(mailto)s Cc=%(mailcc)s ""\n                \'Subject=""%(mailsubject)s"" Attachs=%(mailattachs)d\',\n                {\n                    ""mailto"": to,\n                    ""mailcc"": cc,\n                    ""mailsubject"": subject,\n                    ""mailattachs"": len(attachs),\n                },\n            )\n            return\n\n        dfd = self._sendmail(rcpts, msg.as_string().encode(charset or ""utf-8""))\n        dfd.addCallbacks(\n            callback=self._sent_ok,\n            errback=self._sent_failed,\n            callbackArgs=[to, cc, subject, len(attachs)],\n            errbackArgs=[to, cc, subject, len(attachs)],\n        )\n        reactor.addSystemEventTrigger(""before"", ""shutdown"", lambda: dfd)\n        return dfd\n========================================', 'Output sendmail:\ndef _sendmail(self, to_addrs, msg):\n        from twisted.internet import reactor\n\n        msg = BytesIO(msg)\n        d = defer.Deferred()\n\n        factory = self._create_sender_factory(to_addrs, msg, d)\n\n        if self.smtpssl:\n            reactor.connectSSL(\n                self.smtphost, self.smtpport, factory, ssl.ClientContextFactory()\n            )\n        else:\n            reactor.connectTCP(self.smtphost, self.smtpport, factory)\n\n        return d\n========================================', 'Output SMTP:\ndef _create_sender_factory(self, to_addrs, msg, d):\n        from twisted.mail.smtp import ESMTPSenderFactory\n\n        factory_keywords = {\n            ""heloFallback"": True,\n            ""requireAuthentication"": False,\n            ""requireTransportSecurity"": self.smtptls,\n        }\n\n        # Newer versions of twisted require the hostname to use STARTTLS\n        if twisted_version >= Version(""twisted"", 21, 2, 0):\n            factory_keywords[""hostname""] = self.smtphost\n\n        factory = ESMTPSenderFactory(\n            self.smtpuser,\n            self.smtppass,\n            self.mailfrom,\n            to_addrs,\n            msg,\n            d,\n            **factory_keywords\n        )\n        factory.noisy = False\n        return factory\n========================================', 'Output MIMEMultipart:\ndef send(\n        self,\n        to,\n        subject,\n        body,\n        cc=None,\n        attachs=(),\n        mimetype=""text/plain"",\n        charset=None,\n        _callback=None,\n    ):\n        from twisted.internet import reactor\n\n        if attachs:\n            msg = MIMEMultipart()\n        else:\n            msg = MIMENonMultipart(*mimetype.split(""/"", 1))\n\n        to = list(arg_to_iter(to))\n        cc = list(arg_to_iter(cc))\n\n        msg[""From""] = self.mailfrom\n        msg[""To""] = COMMASPACE.join(to)\n        msg[""Date""] = formatdate(localtime=True)\n        msg[""Subject""] = subject\n        rcpts = to[:]\n        if cc:\n            rcpts.extend(cc)\n            msg[""Cc""] = COMMASPACE.join(cc)\n\n        if attachs:\n            if charset:\n                msg.set_charset(charset)\n            msg.attach(MIMEText(body, ""plain"", charset or ""us-ascii""))\n            for attach_name, mimetype, f in attachs:\n                part = MIMEBase(*mimetype.split(""/""))\n                part.set_payload(f.read())\n                Encoders.encode_base64(part)\n                part.add_header(\n                    ""Content-Disposition"", ""attachment"", filename=attach_name\n                )\n                msg.attach(part)\n        else:\n            msg.set_payload(body, charset)\n\n        if _callback:\n            _callback(to=to, subject=subject, body=body, cc=cc, attach=attachs, msg=msg)\n\n        if self.debug:\n            logger.debug(\n                ""Debug mail sent OK: To=%(mailto)s Cc=%(mailcc)s ""\n                \'Subject=""%(mailsubject)s"" Attachs=%(mailattachs)d\',\n                {\n                    ""mailto"": to,\n                    ""mailcc"": cc,\n                    ""mailsubject"": subject,\n                    ""mailattachs"": len(attachs),\n                },\n            )\n            return\n\n        dfd = self._sendmail(rcpts, msg.as_string().encode(charset or ""utf-8""))\n        dfd.addCallbacks(\n            callback=self._sent_ok,\n            errback=self._sent_failed,\n            callbackArgs=[to, cc, subject, len(attachs)],\n            errbackArgs=[to, cc, subject, len(attachs)],\n        )\n        reactor.addSystemEventTrigger(""before"", ""shutdown"", lambda: dfd)\n        return dfd\n========================================']"
https://raw.githubusercontent.com/python/cpython/df9815eb11b58dfaae02a8e3fb85ae8aa725dc17/Lib/logging/handlers.py,"['SMTP', 'login']","['Output SMTP:\ndef __init__(self, mailhost, fromaddr, toaddrs, subject,\n                 credentials=None, secure=None, timeout=5.0):\n        """"""\n        Initialize the handler.\n\n        Initialize the instance with the from and to addresses and subject\n        line of the email. To specify a non-standard SMTP port, use the\n        (host, port) tuple format for the mailhost argument. To specify\n        authentication credentials, supply a (username, password) tuple\n        for the credentials argument. To specify the use of a secure\n        protocol (TLS), pass in a tuple for the secure argument. This will\n        only be used when authentication credentials are supplied. The tuple\n        will be either an empty tuple, or a single-value tuple with the name\n        of a keyfile, or a 2-value tuple with the names of the keyfile and\n        certificate file. (This tuple is passed to the `starttls` method).\n        A timeout in seconds can be specified for the SMTP connection (the\n        default is one second).\n        """"""\n        logging.Handler.__init__(self)\n        if isinstance(mailhost, (list, tuple)):\n            self.mailhost, self.mailport = mailhost\n        else:\n            self.mailhost, self.mailport = mailhost, None\n        if isinstance(credentials, (list, tuple)):\n            self.username, self.password = credentials\n        else:\n            self.username = None\n        self.fromaddr = fromaddr\n        if isinstance(toaddrs, str):\n            toaddrs = [toaddrs]\n        self.toaddrs = toaddrs\n        self.subject = subject\n        self.secure = secure\n        self.timeout = timeout\n========================================', 'Output SMTP:\ndef emit(self, record):\n        """"""\n        Emit a record.\n\n        Format the record and send it to the specified addressees.\n        """"""\n        try:\n            import smtplib\n            from email.message import EmailMessage\n            import email.utils\n\n            port = self.mailport\n            if not port:\n                port = smtplib.SMTP_PORT\n            smtp = smtplib.SMTP(self.mailhost, port, timeout=self.timeout)\n            msg = EmailMessage()\n            msg[\'From\'] = self.fromaddr\n            msg[\'To\'] = \',\'.join(self.toaddrs)\n            msg[\'Subject\'] = self.getSubject(record)\n            msg[\'Date\'] = email.utils.localtime()\n            msg.set_content(self.format(record))\n            if self.username:\n                if self.secure is not None:\n                    smtp.ehlo()\n                    smtp.starttls(*self.secure)\n                    smtp.ehlo()\n                smtp.login(self.username, self.password)\n            smtp.send_message(msg)\n            smtp.quit()\n        except Exception:\n            self.handleError(record)\n========================================', 'Output login:\ndef emit(self, record):\n        """"""\n        Emit a record.\n\n        Format the record and send it to the specified addressees.\n        """"""\n        try:\n            import smtplib\n            from email.message import EmailMessage\n            import email.utils\n\n            port = self.mailport\n            if not port:\n                port = smtplib.SMTP_PORT\n            smtp = smtplib.SMTP(self.mailhost, port, timeout=self.timeout)\n            msg = EmailMessage()\n            msg[\'From\'] = self.fromaddr\n            msg[\'To\'] = \',\'.join(self.toaddrs)\n            msg[\'Subject\'] = self.getSubject(record)\n            msg[\'Date\'] = email.utils.localtime()\n            msg.set_content(self.format(record))\n            if self.username:\n                if self.secure is not None:\n                    smtp.ehlo()\n                    smtp.starttls(*self.secure)\n                    smtp.ehlo()\n                smtp.login(self.username, self.password)\n            smtp.send_message(msg)\n            smtp.quit()\n        except Exception:\n            self.handleError(record)\n========================================']"
https://raw.githubusercontent.com/NARKOZ/hacker-scripts/b14a0a89bdf743c63ca4cc9cbcd866e050d7b3b0/python3/kumar_asshole.py,"['SMTP', 'login']","[""Output SMTP:\ndef send_reply(subject):\n    yag = yagmail.SMTP(GMAIL_USERNAME)\n    yag.send(\n        to=KUMAR_EMAIL,\n        subject='RE: {}'.format(subject),\n        contents=REPLY_BODY,\n    )\n========================================"", ""Output login:\ndef main():\n    g = gmail.login(GMAIL_USERNAME, GMAIL_PASSWORD)\n    for mail in g.inbox().mail(unread=True, sender=KUMAR_EMAIL, prefetch=True):\n        if KEYWORDS_REGEX.search(mail.body):\n            # Restore DB and send a reply.\n            mail.add_label('Database fixes')\n            send_reply(mail.subject)\n========================================""]"
https://raw.githubusercontent.com/home-assistant/core/0ea0a1ed06983eb451225396979e71f527e0f36a/homeassistant/components/cloud/http_api.py,['login'],"['Output login:\ndef _require_cloud_login(\n    handler: Callable[\n        [HomeAssistant, websocket_api.ActiveConnection, dict[str, Any]],\n        None,\n    ]\n) -> Callable[[HomeAssistant, websocket_api.ActiveConnection, dict[str, Any]], None,]:\n    """"""Websocket decorator that requires cloud to be logged in.""""""\n\n    @wraps(handler)\n    def with_cloud_auth(\n        hass: HomeAssistant,\n        connection: websocket_api.ActiveConnection,\n        msg: dict[str, Any],\n    ) -> None:\n        """"""Require to be logged into the cloud.""""""\n        cloud = hass.data[DOMAIN]\n        if not cloud.is_logged_in:\n            connection.send_message(\n                websocket_api.error_message(\n                    msg[""id""], ""not_logged_in"", ""You need to be logged in to the cloud.""\n                )\n            )\n            return\n\n        handler(hass, connection, msg)\n\n    return with_cloud_auth\n========================================']"
https://raw.githubusercontent.com/vnpy/vnpy/dc60e24199b110509d144c39d05280d43a5be0ed/vnpy/trader/engine.py,"['SMTP', 'login']","['Output SMTP:\ndef run(self) -> None:\n        """"""""""""\n        while self.active:\n            try:\n                msg: EmailMessage = self.queue.get(block=True, timeout=1)\n\n                with smtplib.SMTP_SSL(\n                    SETTINGS[""email.server""], SETTINGS[""email.port""]\n                ) as smtp:\n                    smtp.login(\n                        SETTINGS[""email.username""], SETTINGS[""email.password""]\n                    )\n                    smtp.send_message(msg)\n            except Empty:\n                pass\n========================================', 'Output login:\ndef run(self) -> None:\n        """"""""""""\n        while self.active:\n            try:\n                msg: EmailMessage = self.queue.get(block=True, timeout=1)\n\n                with smtplib.SMTP_SSL(\n                    SETTINGS[""email.server""], SETTINGS[""email.port""]\n                ) as smtp:\n                    smtp.login(\n                        SETTINGS[""email.username""], SETTINGS[""email.password""]\n                    )\n                    smtp.send_message(msg)\n            except Empty:\n                pass\n========================================']"
